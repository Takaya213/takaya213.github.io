import * as React from "react";
import { PropertyControls, ControlType } from "framer";
import * as _ from "lodash";

// source
const loremSource =
	"alias,consequatur,aut,perferendis,sit,voluptatem,accusantium,doloremque,aperiam,eaque,ipsa,quae,ab,illo,inventore,veritatis,et,quasi,architecto,beatae,vitae,dicta,sunt,explicabo,aspernatur,aut,odit,aut,fugit,sed,quia,consequuntur,magni,dolores,eos,qui,ratione,voluptatem,sequi,nesciunt,neque,dolorem,ipsum,quia,dolor,sit,amet,consectetur,adipisci,velit,sed,quia,non,numquam,eius,modi,tempora,incidunt,ut,labore,et,dolore,magnam,aliquam,quaerat,voluptatem,ut,enim,ad,minima,veniam,quis,nostrum,exercitationem,ullam,corporis,nemo,enim,ipsam,voluptatem,quia,voluptas,sit,suscipit,laboriosam,nisi,ut,aliquid,ex,ea,commodi,consequatur,quis,autem,vel,eum,iure,reprehenderit,qui,in,ea,voluptate,velit,esse,quam,nihil,molestiae,et,iusto,odio,dignissimos,ducimus,qui,blanditiis,praesentium,laudantium,totam,rem,voluptatum,deleniti,atque,corrupti,quos,dolores,et,quas,molestias,excepturi,sint,occaecati,cupiditate,non,provident,sed,ut,perspiciatis,unde,omnis,iste,natus,error,similique,sunt,in,culpa,qui,officia,deserunt,mollitia,animi,id,est,laborum,et,dolorum,fuga,et,harum,quidem,rerum,facilis,est,et,expedita,distinctio,nam,libero,tempore,cum,soluta,nobis,est,eligendi,optio,cumque,nihil,impedit,quo,porro,quisquam,est,qui,minus,id,quod,maxime,placeat,facere,possimus,omnis,voluptas,assumenda,est,omnis,dolor,repellendus,temporibus,autem,quibusdam,et,aut,consequatur,vel,illum,qui,dolorem,eum,fugiat,quo,voluptas,nulla,pariatur,at,vero,eos,et,accusamus,officiis,debitis,aut,rerum,necessitatibus,saepe,eveniet,ut,et,voluptates,repudiandae,sint,et,molestiae,non,recusandae,itaque,earum,rerum,hic,tenetur,a,sapiente,delectus,ut,aut,reiciendis,voluptatibus,maiores,doloribus,asperiores,repellat,alias,consequatur,aut,perferendis,sit,voluptatem,accusantium,doloremque,aperiam,eaque,ipsa,quae,ab,illo,inventore,veritatis,et,quasi,architecto,beatae,vitae,dicta,sunt,explicabo,aspernatur,aut,odit,aut,fugit,sed,quia,consequuntur,magni,dolores,eos,qui,ratione,voluptatem,sequi,nesciunt,neque,dolorem,ipsum,quia,dolor,sit,amet,consectetur,adipisci,velit,sed,quia,non,numquam,eius,modi,tempora,incidunt,ut,labore,et,dolore,magnam,aliquam,quaerat,voluptatem,ut,enim,ad,minima,veniam,quis,nostrum,exercitationem,ullam,corporis,nemo,enim,ipsam,voluptatem,quia,voluptas,sit,suscipit,laboriosam,nisi,ut,aliquid,ex,ea,commodi,consequatur,quis,autem,vel,eum,iure,reprehenderit,qui,in,ea,voluptate,velit,esse,quam,nihil,molestiae,et,iusto,odio,dignissimos,ducimus,qui,blanditiis,praesentium,laudantium,totam,rem,voluptatum,deleniti,atque,corrupti,quos,dolores,et,quas,molestias,excepturi,sint,occaecati,cupiditate,non,provident,sed,ut,perspiciatis,unde,omnis,iste,natus,error,similique,sunt,in,culpa,qui,officia,deserunt,mollitia,animi,id,est,laborum,et,dolorum,fuga,et,harum,quidem,rerum,facilis,est,et,expedita,distinctio,nam,libero,tempore,cum,soluta,nobis,est,eligendi,optio,cumque,nihil,impedit,quo,porro,quisquam,est,qui,minus,id,quod,maxime,placeat,facere,possimus,omnis,voluptas,assumenda,est,omnis,dolor,repellendus,temporibus,autem,quibusdam,et,aut,consequatur,vel,illum,qui,dolorem,eum,fugiat,quo,voluptas,nulla,pariatur,at,vero,eos,et,accusamus,officiis,debitis,aut,rerum,necessitatibus,saepe,eveniet,ut,et,voluptates,repudiandae,sint,et,molestiae,non,recusandae,itaque,earum,rerum,hic,tenetur,a,sapiente,delectus,ut,aut,reiciendis,voluptatibus,maiores,doloribus,asperiores,repellat";

// Define type of properties
interface Props {
	width;
	typeface;
	fontSize;
	fontWeight;
	lineHeight;
	color;
	backgroundColor;
	align;
	case;
	flow;
	fillWords;
	minWords;
	maxWords;
	truncate;
	truncateText;
	shuffleContent;
}

export class Lorem extends React.Component<Props> {
	// Set default properties
	static defaultProps = {
		typeface: "Helvetica Neue",
		fontSize: 16,
		fontWeight: "400",
		lineHeight: 1.3,
		color: "#000",
		backgroundColor: "#FFF",
		align: "left",
		case: "sentence",
		flow: "sentences",
		fillWords: true,
		minWords: 64,
		maxWords: 96,
		truncate: false,
		truncateText: "...",
		shuffleContent: false
	};

	strings;
	words;
	sentences;
	paragraphs;
	flow;

	// Items shown in property panel
	static propertyControls: PropertyControls = {
		typeface: { type: ControlType.String, title: "Typeface" },
		fontWeight: {
			type: ControlType.Enum,
			options: ["200", "300", "400", "500", "600", "800"],
			optionTitles: [
				"Extra Light",
				"Light",
				"Regular",
				"Medium",
				"Heavy",
				"Black"
			],
			title: "Weight"
		},
		fontSize: {
			type: ControlType.Number,
			title: "Size",
			min: 6,
			max: 100,
			step: 0.1
		},
		lineHeight: {
			type: ControlType.Number,
			title: "Height",
			min: 0.5,
			max: 4,
			step: 0.1
		},
		color: { type: ControlType.Color, title: "Color" },
		backgroundColor: { type: ControlType.Color, title: "Background" },
		align: {
			type: ControlType.SegmentedEnum,
			options: ["left", "center", "right", "justify"],
			optionTitles: ["L", "C", "R", "J"],
			title: "Align"
		},
		case: {
			type: ControlType.Enum,
			options: ["sentence", "start", "lower", "upper"],
			optionTitles: ["Sentence", "Start", "Lower", "Upper"],
			title: "Case"
		},
		flow: {
			type: ControlType.Enum,
			options: ["words", "sentences", "paragraphs"],
			optionTitles: ["Words", "Sentences", "Paragraphs"],
			title: "Flow"
		},
		fillWords: { type: ControlType.Boolean, title: "Fill" },
		minWords: {
			type: ControlType.Number,
			title: "Min Words",
			min: 1,
			max: 1000,
			hidden: props => props.fillWords
		},
		maxWords: {
			type: ControlType.Number,
			title: "Max Words",
			min: 1,
			max: 1000,
			hidden: props => props.fillWords
		},
		truncate: {
			type: ControlType.Boolean,
			title: "Truncate"
		},
		truncateText: {
			type: ControlType.String,
			title: "Truncate Text",
			hidden: props => !props.truncate
		},
		shuffleContent: { type: ControlType.Boolean, title: "Shuffle" }
	};

	updateValues(props) {
		this.strings = _.shuffle(loremSource.slice().split(","));
		this.words = this.parseWords(props, _.shuffle(this.strings));
		this.sentences = this.parseSentences(this.words);
		this.paragraphs = this.parseParagraphs(this.sentences);
	}

	// Get lorem based on props
	getLorem() {
		switch (this.props.flow) {
			case "words":
				return this.convertToCase(_.join(this.words, " "));
			case "sentences":
				return this.sentences.join("");
			case "paragraphs":
				return this.paragraphs;
		}
	}

	convertToCase(source: string) {
		switch (this.props.case) {
			case "upper":
				return source.toUpperCase();
			case "start":
				return _.startCase(source);
			case "sentence":
				return _.upperFirst(source);
			default:
				return source.toLowerCase();
		}
	}

	parseWords(props, strings: string[]) {
		const { fillWords, minWords, maxWords } = props;

		if (fillWords) {
			return strings.slice();
		} else {
			return strings.slice(0, minWords + (maxWords - minWords));
		}
	}

	// Get lorem ipsum as sentences
	parseSentences(words) {
		let total, count;
		const sentences = [];
		const min = 3;
		const max = 10;

		total = 0;

		const pushSentence = w => {
			sentences.push(this.convertToCase(w.join(" ")) + ". ");
		};

		// Add words to sentence string
		while (total < words.length - max) {
			count = _.random(min, max);
			total += count;

			pushSentence(words.slice(total, total + count));
		}

		// Add all remaining words
		pushSentence(words.slice(total, words.length));

		return sentences;
	}

	// Get lorem ipsum as paragraphs
	parseParagraphs = sentences => {
		let total, count;
		const paragraphs = [];
		const min = 4;
		const max = 7;

		total = 0;

		const pushParagraph = s => {
			paragraphs.push(
				<span
					key={`paragraph_${paragraphs.length}`}
					style={{
						width: "100%",
						display: "block",
						margin: "0 0 1em 0"
					}}
				>
					{s.join(" ")}
				</span>
			);
		};

		while (total < sentences.length - max) {
			count = _.random(min, max);
			total += count;

			pushParagraph(sentences.slice(total, total + count));
		}

		pushParagraph(sentences.slice(total, sentences.length));

		return paragraphs;
	};

	// Update values when component mounts
	componentWillMount() {
		this.updateValues(this.props);
	}

	// Update values if certain conditions are met (or have changed)
	componentWillUpdate(props) {
		let update = false;

		const didChange = prop => this.props[prop] !== props[prop];

		["flow", "case", "minWords", "maxWords", "fillWords"].forEach(prop => {
			if (didChange(prop)) {
				update = true;
			}
		});

		if (!this.props.shuffleContent && props.shuffleContent) {
			update = true;
		}

		if (update || (this.props.shuffleContent && props.shuffleContent)) {
			this.updateValues(props);
		}
	}

	render() {
		const {
			fontWeight,
			color,
			backgroundColor,
			typeface,
			align,
			fontSize,
			lineHeight,
			truncate,
			truncateText
		} = this.props;

		const style: React.CSSProperties = {
			height: "100%",
			overflow: "hidden",
			fontFamily: typeface,
			fontSize: fontSize,
			lineHeight: lineHeight,
			color: color,
			backgroundColor: backgroundColor,
			fontWeight: fontWeight
		};

		const innerStyle: React.CSSProperties = {
			position: "relative",
			textAlign: align,
			overflow: "hidden"
		};

		return (
			<div style={style}>
				<div style={innerStyle}>{this.getLorem()}</div>
				<div
					hidden={!truncate}
					style={{
						position: "absolute",
						right: 1,
						bottom: 0,
						paddingLeft: "8px",
						backgroundColor: backgroundColor ? backgroundColor : "#FFF",
						textAlign: "right"
					}}
				>
					{truncateText}
				</div>
			</div>
		);
	}
}
